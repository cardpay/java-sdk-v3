/*
 * CardPay REST API
 * Welcome to the CardPay REST API. The CardPay API uses HTTP verbs and a [REST](https://en.wikipedia.org/wiki/Representational_state_transfer) resources endpoint structure (see more info about REST). Request and response payloads are formatted as JSON. Merchant uses API to create payments, refunds, payouts or recurrings, check or update transaction status and get information about created transactions. In API authentication process based on [OAuth 2.0](https://oauth.net/2/) standard. For recent changes see changelog section.
 *
 * OpenAPI spec version: 3.0
 * 
 *
 * NOTE: This class is auto generated by the swagger code generator program.
 * https://github.com/swagger-api/swagger-codegen.git
 * Do not edit the class manually.
 */


package com.cardpay.sdk.model;

import com.google.gson.TypeAdapter;
import com.google.gson.annotations.JsonAdapter;
import com.google.gson.annotations.SerializedName;
import com.google.gson.stream.JsonReader;
import com.google.gson.stream.JsonWriter;
import java.io.IOException;
import java.math.BigDecimal;
import java.util.ArrayList;
import java.util.List;
import lombok.Data;

@Data

public class RecurringPlanRequestPlanData {
  @SerializedName("amount")
  private BigDecimal amount = null;
  @SerializedName("currency")
  private String currency = null;
  @SerializedName("interval")
  private Integer interval = null;
  @SerializedName("name")
  private String name = null;
  /**
   * Initial period of recurring, can be &#x60;day&#x60;, &#x60;week&#x60;, &#x60;month&#x60;, &#x60;year&#x60;. Additional period: &#x60;minute&#x60; - for **sandbox** and testing purpose only.
   */
  @JsonAdapter(PeriodEnum.Adapter.class)
  public enum PeriodEnum {
    MINUTE("minute"),
    
    DAY("day"),
    
    WEEK("week"),
    
    MONTH("month"),
    
    YEAR("year");

    private String value;

    PeriodEnum(String value) {
      this.value = value;
    }

    public String getValue() {
      return value;
    }

    @Override
    public String toString() {
      return String.valueOf(value);
    }

    public static PeriodEnum fromValue(String text) {
      for (PeriodEnum b : PeriodEnum.values()) {
        if (String.valueOf(b.value).equals(text)) {
          return b;
        }
      }
      return null;
    }

    public static class Adapter extends TypeAdapter<PeriodEnum> {
      @Override
      public void write(final JsonWriter jsonWriter, final PeriodEnum enumeration) throws IOException {
        jsonWriter.value(enumeration.getValue());
      }

      @Override
      public PeriodEnum read(final JsonReader jsonReader) throws IOException {
        String value = jsonReader.nextString();
        return PeriodEnum.fromValue(String.valueOf(value));
      }
    }
  }

  @SerializedName("period")
  private PeriodEnum period = null;
  @SerializedName("pricing_model")
  private String pricingModel = null;
  @SerializedName("quantity")
  private List<PlanQuantity> quantity = null;
  @SerializedName("retries")
  private Integer retries = null;
  @SerializedName("subscription_decline_logic")
  private PlanSubscriptionDeclineLogic subscriptionDeclineLogic = null;
  
  public void setAmount(BigDecimal amount) {
      this.amount = amount;
  }

  /**
   * @param amount The amount charged per period defined in plan in selected currency with dot as a decimal separator, limit is defined by payment method and transaction details.
   * @return bean instance
   **/
  public RecurringPlanRequestPlanData amount(BigDecimal amount) {
      this.amount = amount;
      return this;
  }

  
  public void setCurrency(String currency) {
      this.currency = currency;
  }

  /**
   * @param currency [ISO 4217](https://en.wikipedia.org/wiki/ISO_4217) currency code of plan
   * @return bean instance
   **/
  public RecurringPlanRequestPlanData currency(String currency) {
      this.currency = currency;
      return this;
  }

  
  public void setInterval(Integer interval) {
      this.interval = interval;
  }

  /**
   * minimum: 1
   * maximum: 365
   * @param interval The frequency interval of period, can be 1-365 depending on selected period value. Maximum value of period + interval can be 365 days / 52 weeks / 12 months / 1 year. From 1 to 60 minutes - for **sandbox** environment and testing purpose only
   * @return bean instance
   **/
  public RecurringPlanRequestPlanData interval(Integer interval) {
      this.interval = interval;
      return this;
  }

  
  public void setName(String name) {
      this.name = name;
  }

  /**
   * @param name Plan name
   * @return bean instance
   **/
  public RecurringPlanRequestPlanData name(String name) {
      this.name = name;
      return this;
  }

  
  public void setPeriod(PeriodEnum period) {
      this.period = period;
  }

  /**
   * @param period Initial period of recurring, can be &#x60;day&#x60;, &#x60;week&#x60;, &#x60;month&#x60;, &#x60;year&#x60;. Additional period: &#x60;minute&#x60; - for **sandbox** and testing purpose only.
   * @return bean instance
   **/
  public RecurringPlanRequestPlanData period(PeriodEnum period) {
      this.period = period;
      return this;
  }

  
  public void setPricingModel(String pricingModel) {
      this.pricingModel = pricingModel;
  }

  /**
   * @param pricingModel Parameter regulates the price calculation pricing_model depending on the number of units Possible values: &#x60;FIXED&#x60; &#x60;TIERED&#x60; &#x60;VOLUME&#x60; By default - &#x60;FIXED&#x60;
   * @return bean instance
   **/
  public RecurringPlanRequestPlanData pricingModel(String pricingModel) {
      this.pricingModel = pricingModel;
      return this;
  }

  
  public void setQuantity(List<PlanQuantity> quantity) {
      this.quantity = quantity;
  }

  /**
   * @param quantity Array with units quantity. Mandatory if &#x60;pricing_model&#x60; is &#x60;TIERED&#x60; or &#x60;VOLUME&#x60;
   * @return bean instance
   **/
  public RecurringPlanRequestPlanData quantity(List<PlanQuantity> quantity) {
      this.quantity = quantity;
      return this;
  }

  public RecurringPlanRequestPlanData addQuantityItem(PlanQuantity quantityItem) {
    if (this.quantity == null) {
      this.quantity = new ArrayList<>();
    }
    this.quantity.add(quantityItem);
    return this;
  }

  
  public void setRetries(Integer retries) {
      this.retries = retries;
  }

  /**
   * minimum: 1
   * maximum: 15
   * @param retries Number of daily basis retry attempts in case of payment has not been captured successfully, from 1 to 15 attempts can be specified.
   * @return bean instance
   **/
  public RecurringPlanRequestPlanData retries(Integer retries) {
      this.retries = retries;
      return this;
  }

  
  public void setSubscriptionDeclineLogic(PlanSubscriptionDeclineLogic subscriptionDeclineLogic) {
      this.subscriptionDeclineLogic = subscriptionDeclineLogic;
  }

  /**
   * @param subscriptionDeclineLogic Subscription decline logic
   * @return bean instance
   **/
  public RecurringPlanRequestPlanData subscriptionDeclineLogic(PlanSubscriptionDeclineLogic subscriptionDeclineLogic) {
      this.subscriptionDeclineLogic = subscriptionDeclineLogic;
      return this;
  }


  @Override
  public String toString() {
     StringBuilder sb = new StringBuilder();
     sb.append("RecurringPlanRequestPlanData( ");
     
     if (amount != null) sb.append("amount=").append(amount.toString()).append("; ");
     if (currency != null) sb.append("currency=").append(currency.toString()).append("; ");
     if (interval != null) sb.append("interval=").append(interval.toString()).append("; ");
     if (name != null) sb.append("name=").append(name.toString()).append("; ");
     if (period != null) sb.append("period=").append(period.toString()).append("; ");
     if (pricingModel != null) sb.append("pricingModel=").append(pricingModel.toString()).append("; ");
     if (quantity != null) sb.append("quantity=").append(quantity.toString()).append("; ");
     if (retries != null) sb.append("retries=").append(retries.toString()).append("; ");
     if (subscriptionDeclineLogic != null) sb.append("subscriptionDeclineLogic=").append(subscriptionDeclineLogic.toString()).append("; ");
     sb.append(")");
     return sb.toString();
  }

}

